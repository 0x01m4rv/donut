; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26726.0 

	TITLE	c:\hub\donut\new\hash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	@maru@12
PUBLIC	@speck@12
EXTRN	_memset:PROC
; Function compile flags: /Ogspy
; File c:\hub\donut\new\hash.c
;	COMDAT @speck@12
_TEXT	SEGMENT
_k$ = -16						; size = 16
_k$3$ = 8						; size = 4
_p$ = 8							; size = 8
@speck@12 PROC						; COMDAT
; _mk$ = ecx

; 35   : uint64_t speck(void *mk, uint64_t p) {

	sub	esp, 16					; 00000010H

; 36   :     uint32_t k[4], i, t;
; 37   :     union {
; 38   :       uint32_t w[2];
; 39   :       uint64_t q;
; 40   :     } x;
; 41   :     
; 42   :     // copy plaintext to local buffer
; 43   :     x.q = p;

	mov	eax, DWORD PTR _p$[esp+12]
	mov	edx, DWORD PTR _p$[esp+16]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	lea	edi, DWORD PTR _k$[esp+32]

; 44   :     
; 45   :     // copy master key to local buffer
; 46   :     for(i=0;i<4;i++) k[i]=((uint32_t*)mk)[i];
; 47   :     
; 48   :     for(i=0;i<27;i++) {

	xor	ebx, ebx
	movsd
	movsd
	movsd
	movsd
	mov	ecx, DWORD PTR _k$[esp+36]
	mov	esi, DWORD PTR _k$[esp+44]
	mov	ebp, DWORD PTR _k$[esp+40]
	mov	edi, DWORD PTR _k$[esp+32]
	mov	DWORD PTR _k$3$[esp+28], ecx
$LL7@:

; 49   :       // encrypt plaintext
; 50   :       x.w[0] = (ROTR32(x.w[0], 8) + x.w[1]) ^ k[0];
; 51   :       x.w[1] =  ROTR32(x.w[1],29) ^ x.w[0];
; 52   :       
; 53   :       // create next subkey
; 54   :       t = k[3];

	mov	ecx, esi
	ror	eax, 8

; 55   :       k[3] = (ROTR32(k[1], 8) + k[0]) ^ i;

	mov	esi, DWORD PTR _k$3$[esp+28]
	add	eax, edx
	ror	esi, 8
	xor	eax, edi
	add	esi, edi
	rol	edx, 3
	xor	esi, ebx

; 56   :       k[0] =  ROTR32(k[0],29) ^ k[3];

	rol	edi, 3
	xor	edx, eax

; 57   :       k[1] = k[2]; k[2] = t;

	mov	DWORD PTR _k$3$[esp+28], ebp
	xor	edi, esi
	mov	ebp, ecx
	inc	ebx
	cmp	ebx, 27					; 0000001bH
	jb	SHORT $LL7@

; 58   :     }
; 59   :     // return 64-bit ciphertext
; 60   :     return x.q;

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 61   : }

	add	esp, 16					; 00000010H
	ret	8
@speck@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\donut\new\hash.c
;	COMDAT @maru@12
_TEXT	SEGMENT
_end$1$ = -24						; size = 4
_api$1$ = -20						; size = 4
_m$ = -16						; size = 16
_h$2$ = 8						; size = 4
_iv$ = 8						; size = 8
@maru@12 PROC						; COMDAT
; _api$ = ecx

; 63   : uint64_t maru(const char *api, uint64_t iv) {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 64   :     uint64_t h;
; 65   :     uint32_t len, idx, end, i;
; 66   :     
; 67   :     union {
; 68   :       uint8_t  b[MARU_BLK_LEN];
; 69   :       uint32_t w[MARU_BLK_LEN/4];
; 70   :     } m;
; 71   :     
; 72   :     // set H to initial value
; 73   :     h = iv;

	mov	ebp, DWORD PTR _iv$[esp+28]

; 74   :     
; 75   :     for(idx=0, len=0, end=0;!end;) {

	xor	ebx, ebx
	push	esi
	mov	esi, DWORD PTR _iv$[esp+36]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _api$1$[esp+40], ecx
	xor	eax, eax
	mov	DWORD PTR _h$2$[esp+36], esi
	mov	DWORD PTR _end$1$[esp+40], eax
$LL2@:

; 76   :       // end of string or max len?
; 77   :       if(api[len] == 0 || len == MARU_MAX_STR) {

	mov	cl, BYTE PTR [ebx+ecx]
	test	cl, cl
	je	SHORT $LN7@
	cmp	ebx, 64					; 00000040H
	je	SHORT $LN7@

; 93   :       } else {    
; 94   :         // store character from api string
; 95   :         m.b[idx] = (uint8_t)api[len]; 

	mov	BYTE PTR _m$[esp+edi+40], cl

; 96   :         idx++; len++;

	inc	edi
	inc	ebx
	jmp	SHORT $LN6@
$LN7@:

; 78   :         // zero remainder of M
; 79   :         memset(&m.b[idx], 0, MARU_BLK_LEN - idx);

	push	16					; 00000010H
	pop	eax
	sub	eax, edi
	lea	esi, DWORD PTR _m$[esp+40]
	push	eax
	add	esi, edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 80   :         // store the end bit
; 81   :         m.b[idx] = 0x80;

	mov	BYTE PTR [esi], 128			; 00000080H

; 82   :         // have we space in M for api length?
; 83   :         if(idx >= MARU_BLK_LEN - 4) {

	mov	esi, DWORD PTR _h$2$[esp+36]
	cmp	edi, 12					; 0000000cH
	jb	SHORT $LN8@

; 84   :           // no, update H with E
; 85   :           h ^= MARU_CRYPT(&m, h);

	push	esi
	push	ebp
	lea	ecx, DWORD PTR _m$[esp+48]
	call	@speck@12
	xor	ebp, eax

; 86   :           // zero M
; 87   :           memset(&m, 0, MARU_BLK_LEN);

	lea	edi, DWORD PTR _m$[esp+40]
	xor	esi, edx
	xor	eax, eax
	stosd
	mov	DWORD PTR _h$2$[esp+36], esi
	stosd
	stosd
	stosd
$LN8@:

; 88   :         }
; 89   :         // store total length in bits
; 90   :         m.w[(MARU_BLK_LEN/4)-1] = (len * 8);

	mov	eax, ebx
	shl	eax, 3
	mov	DWORD PTR _m$[esp+52], eax

; 91   :         idx = MARU_BLK_LEN;
; 92   :         end++;

	mov	eax, DWORD PTR _end$1$[esp+40]
	push	16					; 00000010H
	inc	eax
	pop	edi
	mov	DWORD PTR _end$1$[esp+40], eax
$LN6@:

; 97   :       }
; 98   :       if(idx == MARU_BLK_LEN) {

	cmp	edi, 16					; 00000010H
	jne	SHORT $LN9@

; 99   :         // update H with E
; 100  :         h ^= MARU_CRYPT(&m, h);

	push	esi
	push	ebp
	lea	ecx, DWORD PTR _m$[esp+48]
	call	@speck@12
	xor	esi, edx
	xor	ebp, eax
	mov	eax, DWORD PTR _end$1$[esp+40]

; 101  :         // reset idx
; 102  :         idx = 0;

	xor	edi, edi
	mov	DWORD PTR _h$2$[esp+36], esi
$LN9@:

; 74   :     
; 75   :     for(idx=0, len=0, end=0;!end;) {

	mov	ecx, DWORD PTR _api$1$[esp+40]
	test	eax, eax
	je	$LL2@

; 103  :       }
; 104  :     }  
; 105  :     return h;

	pop	edi
	mov	edx, esi
	mov	eax, ebp
	pop	esi
	pop	ebp
	pop	ebx

; 106  : }

	add	esp, 24					; 00000018H
	ret	8
@maru@12 ENDP
_TEXT	ENDS
END
